{"ast":null,"code":"import io from 'socket.io-client';\nclass SocketService {\n  constructor() {\n    this.socket = null;\n    this.connected = false;\n    this.listeners = new Map();\n  }\n  async initialize() {\n    const serverUrl = process.env.REACT_APP_BACKEND_URL || 'http://localhost:5000';\n    console.log('Connecting to server:', serverUrl);\n    this.socket = io(serverUrl, {\n      transports: ['websocket', 'polling'],\n      timeout: 20000,\n      reconnection: true,\n      reconnectionDelay: 1000,\n      reconnectionAttempts: 5,\n      maxReconnectionAttempts: 10\n    });\n    return new Promise((resolve, reject) => {\n      // Set up connection event handlers\n      this.socket.on('connect', () => {\n        console.log('Socket connected successfully');\n        this.connected = true;\n        resolve();\n      });\n      this.socket.on('connect_error', error => {\n        console.error('Socket connection error:', error);\n        this.connected = false;\n        reject(error);\n      });\n      this.socket.on('disconnect', reason => {\n        console.log('Socket disconnected:', reason);\n        this.connected = false;\n\n        // Attempt to reconnect if disconnection wasn't intentional\n        if (reason === 'io server disconnect') {\n          this.socket.connect();\n        }\n      });\n      this.socket.on('reconnect', attemptNumber => {\n        console.log('Socket reconnected after', attemptNumber, 'attempts');\n        this.connected = true;\n      });\n      this.socket.on('reconnect_error', error => {\n        console.error('Socket reconnection failed:', error);\n      });\n      this.socket.on('reconnect_failed', () => {\n        console.error('Socket reconnection failed after maximum attempts');\n        this.connected = false;\n      });\n\n      // Timeout for initial connection\n      setTimeout(() => {\n        if (!this.connected) {\n          reject(new Error('Socket connection timeout'));\n        }\n      }, 10000);\n    });\n  }\n  on(event, callback) {\n    if (this.socket) {\n      this.socket.on(event, callback);\n\n      // Store listener for cleanup\n      if (!this.listeners.has(event)) {\n        this.listeners.set(event, []);\n      }\n      this.listeners.get(event).push(callback);\n    } else {\n      console.warn('Socket not initialized. Call initialize() first.');\n    }\n  }\n  off(event, callback) {\n    if (this.socket) {\n      this.socket.off(event, callback);\n\n      // Remove from stored listeners\n      if (this.listeners.has(event)) {\n        const callbacks = this.listeners.get(event);\n        const index = callbacks.indexOf(callback);\n        if (index > -1) {\n          callbacks.splice(index, 1);\n        }\n        if (callbacks.length === 0) {\n          this.listeners.delete(event);\n        }\n      }\n    }\n  }\n  emit(event, data) {\n    if (this.socket && this.connected) {\n      this.socket.emit(event, data);\n      console.log(`Emitted event: ${event}`, data);\n    } else {\n      console.warn('Socket not connected. Cannot emit event:', event);\n    }\n  }\n  disconnect() {\n    if (this.socket) {\n      // Clean up all listeners\n      this.listeners.forEach((callbacks, event) => {\n        callbacks.forEach(callback => {\n          this.socket.off(event, callback);\n        });\n      });\n      this.listeners.clear();\n      this.socket.disconnect();\n      this.socket = null;\n      this.connected = false;\n      console.log('Socket disconnected and cleaned up');\n    }\n  }\n  isConnected() {\n    return this.connected;\n  }\n\n  // Convenience methods for common operations\n  startSimulation() {\n    this.emit('start_simulation');\n  }\n  stopSimulation() {\n    this.emit('stop_simulation');\n  }\n  triggerEmergency(scenario) {\n    this.emit('trigger_emergency', {\n      scenario\n    });\n  }\n  clearAlert(alertId) {\n    this.emit('clear_alert', {\n      alertId\n    });\n  }\n  requestDeviceData(deviceId) {\n    this.emit('request_device_data', {\n      deviceId\n    });\n  }\n  requestEdgeNodeData(nodeId) {\n    this.emit('request_edge_node_data', {\n      nodeId\n    });\n  }\n}\n\n// Export singleton instance\nconst socketService = new SocketService();\nexport { socketService as SocketService };\nexport default socketService;","map":{"version":3,"names":["io","SocketService","constructor","socket","connected","listeners","Map","initialize","serverUrl","process","env","REACT_APP_BACKEND_URL","console","log","transports","timeout","reconnection","reconnectionDelay","reconnectionAttempts","maxReconnectionAttempts","Promise","resolve","reject","on","error","reason","connect","attemptNumber","setTimeout","Error","event","callback","has","set","get","push","warn","off","callbacks","index","indexOf","splice","length","delete","emit","data","disconnect","forEach","clear","isConnected","startSimulation","stopSimulation","triggerEmergency","scenario","clearAlert","alertId","requestDeviceData","deviceId","requestEdgeNodeData","nodeId","socketService"],"sources":["D:/smart_city_communication_hub/frontend/src/services/socketService.js"],"sourcesContent":["import io from 'socket.io-client';\r\n\r\nclass SocketService {\r\n  constructor() {\r\n    this.socket = null;\r\n    this.connected = false;\r\n    this.listeners = new Map();\r\n  }\r\n\r\n  async initialize() {\r\n    const serverUrl = process.env.REACT_APP_BACKEND_URL || 'http://localhost:5000';\r\n    \r\n    console.log('Connecting to server:', serverUrl);\r\n    \r\n    this.socket = io(serverUrl, {\r\n      transports: ['websocket', 'polling'],\r\n      timeout: 20000,\r\n      reconnection: true,\r\n      reconnectionDelay: 1000,\r\n      reconnectionAttempts: 5,\r\n      maxReconnectionAttempts: 10\r\n    });\r\n\r\n    return new Promise((resolve, reject) => {\r\n      // Set up connection event handlers\r\n      this.socket.on('connect', () => {\r\n        console.log('Socket connected successfully');\r\n        this.connected = true;\r\n        resolve();\r\n      });\r\n\r\n      this.socket.on('connect_error', (error) => {\r\n        console.error('Socket connection error:', error);\r\n        this.connected = false;\r\n        reject(error);\r\n      });\r\n\r\n      this.socket.on('disconnect', (reason) => {\r\n        console.log('Socket disconnected:', reason);\r\n        this.connected = false;\r\n        \r\n        // Attempt to reconnect if disconnection wasn't intentional\r\n        if (reason === 'io server disconnect') {\r\n          this.socket.connect();\r\n        }\r\n      });\r\n\r\n      this.socket.on('reconnect', (attemptNumber) => {\r\n        console.log('Socket reconnected after', attemptNumber, 'attempts');\r\n        this.connected = true;\r\n      });\r\n\r\n      this.socket.on('reconnect_error', (error) => {\r\n        console.error('Socket reconnection failed:', error);\r\n      });\r\n\r\n      this.socket.on('reconnect_failed', () => {\r\n        console.error('Socket reconnection failed after maximum attempts');\r\n        this.connected = false;\r\n      });\r\n\r\n      // Timeout for initial connection\r\n      setTimeout(() => {\r\n        if (!this.connected) {\r\n          reject(new Error('Socket connection timeout'));\r\n        }\r\n      }, 10000);\r\n    });\r\n  }\r\n\r\n  on(event, callback) {\r\n    if (this.socket) {\r\n      this.socket.on(event, callback);\r\n      \r\n      // Store listener for cleanup\r\n      if (!this.listeners.has(event)) {\r\n        this.listeners.set(event, []);\r\n      }\r\n      this.listeners.get(event).push(callback);\r\n    } else {\r\n      console.warn('Socket not initialized. Call initialize() first.');\r\n    }\r\n  }\r\n\r\n  off(event, callback) {\r\n    if (this.socket) {\r\n      this.socket.off(event, callback);\r\n      \r\n      // Remove from stored listeners\r\n      if (this.listeners.has(event)) {\r\n        const callbacks = this.listeners.get(event);\r\n        const index = callbacks.indexOf(callback);\r\n        if (index > -1) {\r\n          callbacks.splice(index, 1);\r\n        }\r\n        if (callbacks.length === 0) {\r\n          this.listeners.delete(event);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  emit(event, data) {\r\n    if (this.socket && this.connected) {\r\n      this.socket.emit(event, data);\r\n      console.log(`Emitted event: ${event}`, data);\r\n    } else {\r\n      console.warn('Socket not connected. Cannot emit event:', event);\r\n    }\r\n  }\r\n\r\n  disconnect() {\r\n    if (this.socket) {\r\n      // Clean up all listeners\r\n      this.listeners.forEach((callbacks, event) => {\r\n        callbacks.forEach(callback => {\r\n          this.socket.off(event, callback);\r\n        });\r\n      });\r\n      this.listeners.clear();\r\n      \r\n      this.socket.disconnect();\r\n      this.socket = null;\r\n      this.connected = false;\r\n      console.log('Socket disconnected and cleaned up');\r\n    }\r\n  }\r\n\r\n  isConnected() {\r\n    return this.connected;\r\n  }\r\n\r\n  // Convenience methods for common operations\r\n  startSimulation() {\r\n    this.emit('start_simulation');\r\n  }\r\n\r\n  stopSimulation() {\r\n    this.emit('stop_simulation');\r\n  }\r\n\r\n  triggerEmergency(scenario) {\r\n    this.emit('trigger_emergency', { scenario });\r\n  }\r\n\r\n  clearAlert(alertId) {\r\n    this.emit('clear_alert', { alertId });\r\n  }\r\n\r\n  requestDeviceData(deviceId) {\r\n    this.emit('request_device_data', { deviceId });\r\n  }\r\n\r\n  requestEdgeNodeData(nodeId) {\r\n    this.emit('request_edge_node_data', { nodeId });\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nconst socketService = new SocketService();\r\nexport { socketService as SocketService };\r\nexport default socketService;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}